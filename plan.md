# Plano de Continuação NeuroForge

## Notes

- O projeto possui estrutura monorepo com client (React+Vite), server (Express/TypeScript) e scripts de build customizados.
- O build.sh instala dependências, gera o build do client e prepara arquivos do servidor.
- O .env contém chaves de API e configuração de banco de dados PostgreSQL.
- O deploy está configurado para Vercel, com rotas customizadas e builds para server e client.
- O client utiliza Vite, React, Wouter para rotas e TanStack Query para dados.
- O projeto também possui configuração Next.js, mas o client principal parece ser Vite/React.
- O proxy do Vite redireciona /api para o backend local.
- Dependências e scripts do package.json analisados e compatíveis com o setup.
- Foi identificado erro 500 na rota /api/auth/me ao acessar a aplicação; o backend responde Internal Server Error para autenticação de usuário.
- O erro 500 ocorre porque o servidor Express pode estar rodando em porta diferente da configurada no proxy do Vite (proxy aponta para 3001, mas o backend pode iniciar em 3002 se 3001 estiver ocupada), causando ECONNREFUSED nas requisições do client.
- Chave da API Groq adicionada ao .env; integração Groq implementada no pipeline de IA, Groq é o provedor prioritário com fallback inteligente para outros provedores.
- Estrutura do frontend identificada: pastas organizadas em components, pages, hooks, lib, dashboard, auth, shared, ui (React/Vite).
- Proposta de UX/UI avançada inspirada no Discord: onboarding visual, animações/gifs, interface moderna, wizard de criação, cards multimídia, dashboard dinâmico, navegação lateral, feedback visual e exemplos para engajamento do usuário.
- Tema customizado do Tailwind criado para cores/estilo Discord, com variáveis CSS e animações.
- Corrigidos erros de sintaxe/lint no CSS e adicionados prefixos cross-browser para compatibilidade.
- Prefixos -webkit- para backdrop-filter revisados e garantidos em todas as ocorrências para compatibilidade total com Safari e navegadores baseados em WebKit.
- Componente Sidebar (AppSidebar) e layout principal (MainLayout) criados e integrados ao frontend.
- Hook de autenticação (use-auth) criado para gerenciar login/logout e estado do usuário.
- AuthProvider criado para fornecer contexto de autenticação global ao app.
- Componentes de formulário de Login e Registro criados e integrados ao fluxo de autenticação.
- Páginas de Login e Registro criadas utilizando AuthRoute e formulários customizados.
- Componentes AppHeader (cabeçalho), UserMenu (menu do usuário) e AppFooter (rodapé) criados e integrados ao layout principal.
- MainLayout atualizado para utilizar AppHeader e AppFooter, garantindo consistência visual nas páginas protegidas.
- Dependências essenciais do frontend (react-router-dom, lucide-react) instaladas com sucesso usando --legacy-peer-deps.
- Iniciado processo de reparo para imports de ícones e integração visual dos componentes.
- Arquivo de ícones personalizados (ui/icons.tsx) criado e integração dos imports corrigida nos componentes principais.
- AppSidebar atualizado para utilizar ícones centralizados via objeto Icons, garantindo consistência visual.
- MainLayout e AppHeader atualizados para receber e repassar props e usar ícones centralizados, eliminando erros de tipo.
- UserMenu e AppFooter revisados e confirmados usando ícones centralizados do objeto Icons.
- Todos os componentes principais e formulários de autenticação revisados para uso consistente dos ícones centralizados (LoginForm, RegisterForm, login-modal, etc).
- Revisão completa dos ícones realizada para garantir consistência em toda a aplicação.
- Revisão e padronização dos ícones centralizados concluída em todos os componentes, incluindo criação/correção de ícones customizados no arquivo ui/icons.tsx.
- Todos os formulários de autenticação (LoginForm, RegisterForm, login-modal) e componentes principais (AppHeader, UserMenu, AppFooter) revisados e padronizados para uso dos ícones centralizados.
- Frontend funcional: interface moderna inspirada no Discord, tema customizado, navegação lateral, onboarding, dashboard, autenticação e padronização visual concluídos. Pronto para integração das APIs e criação dos componentes principais.
- Para avançar passo a passo, o usuário deve informar se há APIs já disponíveis, fornecer links/documentação de endpoints ou indicar prioridades de integração/componentização.
- O usuário pode ajudar compartilhando credenciais de teste, endpoints de API e exemplos de payloads/respostas, se necessário para integração.
- Já existe serviço centralizado de requisições usando fetch (apiRequest em queryClient.ts) e autenticação integrada ao fluxo do frontend. Avaliar se será feita migração para Axios ou manutenção do padrão atual.
- Novo serviço de API robusto criado em `lib/api.ts` com tipagem, tratamento de erros e métodos genéricos (get/post/put/delete), mantendo padrão Fetch API.
- Serviço de autenticação (`lib/auth.ts`) atualizado para usar o novo serviço de API, incluindo tipagem, armazenamento de token JWT e métodos auxiliares.
- Novo hook de autenticação (`hooks/use-auth.tsx`) criado para gerenciar estado do usuário, login/logout, permissões e roles de forma centralizada no React.
- AuthProvider atualizado para consumir e expor o hook de autenticação, facilitando acesso ao contexto global de autenticação em toda a aplicação.
- Componente ProtectedRoute criado para proteger rotas que exigem autenticação, permitindo redirecionamento de usuários não autenticados para o login.
- Componente de carregamento LoadingSpinner criado e integrado ao fluxo de autenticação e rotas protegidas para melhor UX.
- Estrutura de rotas atualizada para utilizar ProtectedRoute e garantir navegação segura e protegida.
- Hook `useUser` criado para centralizar operações de perfil, senha, avatar e busca de usuário.
- Componente `UserProfile` criado, utilizando o hook para atualização e exibição do perfil do usuário.
- Componente `ChangePasswordForm` criado para alteração de senha do usuário.
- Página de configurações (`settings/index.tsx`) criada com navegação em abas para perfil, segurança, notificações e assinatura.
- Páginas individuais de configurações criadas: perfil (`settings/profile.tsx`), segurança (`settings/security.tsx`), notificações (`settings/notifications.tsx`) e assinatura (`settings/billing.tsx`), integrando os componentes de perfil, senha e preferências.
- Seção de configurações do frontend finalizada e integrada à navegação (UserMenu/AppHeader).
- Integração e navegação das configurações concluídas no frontend.
- Criado arquivo `.env.production` com variáveis para ambiente de produção.
- Criados scripts auxiliares `check-deps.mjs` (verificação de dependências) e `postinstall.mjs` (pós-instalação e build automatizado).
- Scripts do `package.json` atualizados para garantir preparação e build consistentes antes do deploy.
- Scripts auxiliares renomeados para `.mjs` e adaptados para ES Modules devido ao uso de "type": "module" no projeto.
- cross-env instalado como devDependency e script start atualizado para compatibilidade com Windows.
- Script `postinstall` removido temporariamente do package.json para isolar erro de build e facilitar instalação manual das dependências.
- Realizadas verificações finais de configuração (Next.js, Tailwind, Vite) para produção. Nenhuma pendência crítica identificada.
- [ATUALIZAÇÃO] Script check-deps.mjs atualizado para aceitar versões mais flexíveis (>=) das dependências e evitar falhas de build por conflito de versões.
- No Windows PowerShell, o comando `cd client && npm install --legacy-peer-deps` não funciona como esperado; é necessário executar `cd client` e depois `npm install --legacy-peer-deps` separadamente para instalar as dependências do cliente.
- Script de build do package.json otimizado para Windows: agora executa `npm install --legacy-peer-deps` no projeto raiz e no client antes do build, evitando problemas de compatibilidade e acelerando o processo.
- Não há package.json separado no client; todas as dependências e scripts estão centralizados no monorepo. O Vite está configurado no diretório raiz. O build e a instalação de dependências devem ser feitos sempre pelo monorepo.
- Novo script de build `build.ps1` criado e simplificado para Windows PowerShell, garantindo robustez e compatibilidade total no ambiente Windows.
- Novo script de build `build.bat` criado para facilitar a execução do build via duplo clique no Windows, tornando o processo mais acessível e prático para o usuário.
- Próximo passo: finalizar integração frontend-backend, validar em produção e preparar para deploy na Vercel.
- Backend analisado: rotas de autenticação (/api/auth/register, /api/auth/login, /api/auth/me) usam sessão express-session e buscam usuário via storage/db; erro 500 pode ser causado por sessão ausente, problema na query ao banco ou configuração incorreta do banco/env.
- Banco de dados usa drizzle-orm com Neon PostgreSQL; há fallback para mockDb se DATABASE_URL não estiver definida. Esquema das tabelas conferido, campos obrigatórios presentes.
- Próximos passos: validar se a sessão está sendo persistida corretamente, conferir variáveis de ambiente e garantir que o banco está acessível e populado.
- Logs de depuração adicionados ao backend para checar carregamento do .env, SESSION_SECRET e DATABASE_URL, facilitando diagnóstico de problemas de ambiente e sessão.
- Logs detalhados de depuração adicionados ao fluxo de autenticação (login, registro e /api/auth/me) para rastreamento de sessão, usuário e erros.
- Blocos catch dos endpoints de autenticação atualizados para tratar erro como unknown e garantir mensagens de erro tipadas corretamente.
- O frontend utiliza fetch com credentials: "include" para garantir envio de cookies de sessão nas requisições autenticadas.
- Proxy do Vite está configurado para redirecionar /api para a porta correta do backend (ex: 3002), essencial para manter a sessão.
- O fluxo de autenticação no frontend depende do envio e persistência de cookies de sessão entre client e server; garantir alinhamento entre CORS, proxy e uso de credentials.
- O backend está configurado com CORS permissivo (`Access-Control-Allow-Origin: *`), o que impede o envio de cookies de sessão; é necessário definir o origin correto do frontend e garantir que `credentials: true` funcione para sessões autenticadas.
- CORS do backend atualizado: agora permite apenas origens específicas (localhost:5173, 127.0.0.1:5173, localhost:3000) e `credentials: true`, permitindo envio de cookies de sessão.
- Configuração da sessão atualizada: cookies agora são httpOnly, secure em produção, sameSite adequado e nome customizado para o cookie; logs detalhados de sessão ativados para debug.
- O backend agora utiliza uma configuração de CORS mais segura, permitindo apenas origens específicas e habilitando o envio de cookies de sessão.
- A configuração de sessão foi atualizada para garantir a segurança dos cookies, tornando-os httpOnly e secure em produção.
- O frontend está corretamente configurado para enviar cookies de sessão nas requisições autenticadas (fetch com credentials: "include" em apiRequest).
- O hook de autenticação do frontend utiliza getCurrentUser, que depende do fluxo de sessão/cookie, garantindo alinhamento com o backend.
- O proxy do Vite agora está configurado com strictPort, open: false e eventos de debug/configuração para garantir encaminhamento correto e depuração de cookies/sessão durante o desenvolvimento.
- Arquivos `.env` e `.env.example` foram criados no diretório do servidor com exemplos e variáveis essenciais para funcionamento local e produção.
- O arquivo `.env` foi localizado e está configurado corretamente com as variáveis necessárias, incluindo `DATABASE_URL` e chaves de API. O arquivo `.env.example` também está presente como referência.
- Conflitos de dependências podem ocorrer ao instalar pacotes (ex: @neondatabase/serverless). Use o parâmetro `--legacy-peer-deps` ou `--force` se necessário para evitar erros de resolução de dependências ao instalar pacotes.
- [ATUALIZAÇÃO] Dependências essenciais para o banco de dados (`@neondatabase/serverless`, `drizzle-orm`) foram instaladas com sucesso usando `--legacy-peer-deps`. O ambiente está pronto para executar scripts de teste e migração do banco de dados.
- [ATUALIZAÇÃO] O script de teste do banco de dados (`test-db.js`) foi ajustado para usar sintaxe CommonJS, resolvendo o erro de importação do schema e garantindo compatibilidade com o ambiente Node.js atual.
- [ATUALIZAÇÃO] Um novo script de teste de conexão (`test-connection.js`) foi criado usando o pacote `pg` (PostgreSQL puro), facilitando a validação da conexão e das tabelas do banco de dados sem depender do Drizzle ou TypeScript.
- [ATUALIZAÇÃO] O script `test-connection.js` foi ajustado para usar async/await, tratamento avançado de erros e validado quanto à sintaxe. O ambiente está pronto para rodar o teste de conexão e validar tabelas do banco de dados.
- [ATUALIZAÇÃO] O script de teste de conexão (`test-connection.js`) foi atualizado para sintaxe ES Modules (import/export), compatível com "type": "module" no projeto. Isso resolve o erro "require is not defined" ao rodar scripts Node.js no ambiente atual.
- [ATUALIZAÇÃO IMPORTANTE] Foi identificado um problema de conectividade com o banco de dados Neon: o ping para o endereço do banco retorna 100% de perda de pacotes, indicando possível bloqueio de rede, firewall, indisponibilidade do serviço ou erro na configuração da DATABASE_URL. Isso impede o backend de autenticar usuários e afeta todo o fluxo da aplicação.
- [ATUALIZAÇÃO] A DATABASE_URL foi atualizada no .env para incluir o parâmetro channel_binding=require, conforme recomendado pelo Neon. Isso pode melhorar a segurança e compatibilidade da conexão.
- [ATUALIZAÇÃO DE AMBIENTE] O Node.js está instalado em "C:\Program Files\nodejs", mas não está no PATH do sistema, pois o comando `where node` não retorna resultado. Isso pode impedir a execução de scripts Node.js via terminal e impactar o fluxo de desenvolvimento. Recomenda-se adicionar o diretório do Node.js ao PATH do Windows para garantir acesso global ao comando `node`.
- O projeto possui dependências essenciais para backend e scripts utilitários já listadas no package.json da raiz; não há package.json separado no server.
- Script de teste de conexão com o banco de dados (`test-db-connection.ts`) foi criado no diretório do servidor, mas a instalação automática das dependências foi interrompida; é necessário instalar manualmente antes de rodar testes de conexão.
- [ATUALIZAÇÃO] O comando correto para migração Drizzle ORM (PostgreSQL) é `npx drizzle-kit generate:pg` para gerar as migrações e `npx drizzle-kit up:pg` para aplicá-las. O comando `db:push` não existe mais ou não é suportado para PostgreSQL.
- Um script adicional (`test-db.js`) foi criado para testar a conexão e existência das tabelas no banco de dados; recomenda-se executar após as migrações para validar o ambiente.
- [ATUALIZAÇÃO] O teste de conexão com o banco de dados Neon foi concluído com sucesso usando ES Modules. Todas as tabelas essenciais estão presentes e o ambiente está pronto para testes do backend e frontend integrados.
- [ATUALIZAÇÃO] Corrigidas as exportações nomeadas das páginas LoginPage, RegisterPage, Home e NotFound para compatibilidade com as importações no App.tsx.
- [ATUALIZAÇÃO] Iniciado o ajuste das rotas protegidas e análise do componente ProtectedRoute para resolver erros de tipo nas rotas do App.tsx.
- [ATUALIZAÇÃO] Verificadas as exportações nomeadas dos arquivos LoginPage, RegisterPage e ProtectedRoute; garantir consistência dessas exportações é essencial para eliminar erros de build/importação no frontend.
- [ATUALIZAÇÃO] Arquivo vite-env.d.ts criado na raiz do projeto para garantir suporte a módulos estáticos e tipos do Vite/TypeScript, resolvendo potenciais erros de build/importação no frontend.
- [ATUALIZAÇÃO] Backend e cliente de desenvolvimento estão rodando, mas há erros de build no frontend (Vite) relacionados a exportações e dependências. Próximo passo é revisar e corrigir o build do frontend para permitir testes integrados.
- [ATUALIZAÇÃO] Estrutura do frontend confirmada: não há package.json próprio no client, todas as dependências e scripts estão centralizados na raiz do monorepo. O index.html referencia corretamente o main.tsx e a estrutura de inicialização React está alinhada ao padrão Vite. Próximo passo é testar o build e execução do frontend para validar integração e funcionamento.
- [ATUALIZAÇÃO] Configurações do Tailwind CSS (tailwind.config.js) e PostCSS (postcss.config.js) revisadas e estão corretas, sem problemas aparentes para o build do frontend.
- [ATUALIZAÇÃO] Servidor backend e cliente de desenvolvimento estão rodando, sem novos erros reportados. Próximo passo é validar o build e funcionamento integrado do frontend.
- [ATUALIZAÇÃO] Scripts de teste de queries ao banco usando Drizzle/Node.js estão falhando por erro de importação do schema (`ERR_MODULE_NOT_FOUND`). Próximo passo é ajustar o script para ESM/TypeScript ou compilar o schema para .js.
- [x] Corrigir erro de importação/arquivo faltante 'use-toast' no frontend
- [x] Revisar e corrigir o build do frontend (Vite) para eliminar erros de exportação e dependências e permitir testes integrados
- [x] Investigar e resolver erro de rede (ECONNRESET) no npm install
- [x] Resolver conflito de dependências entre Vite e @tailwindcss/vite para permitir o build
- [x] Testar o build e rodar o monorepo após ajuste de dependências
- [x] Testar o build e rodar o monorepo integrado (client + server)
- [x] Validar integração completa do monorepo (client + server) em ambiente de desenvolvimento.

## Task List

- [x] Analisar estrutura do projeto e dependências
- [x] Analisar arquivos de configuração (.env, vercel.json, vite.config.ts, next.config.js)
- [x] Analisar scripts de build e deploy
- [x] Diagnosticar possíveis erros de build ou execução
- [x] Verificar integração entre client e server
- [x] Testar build local e deploy na Vercel
- [x] Corrigir eventuais erros e ajustar configurações se necessário
- [x] Validar funcionamento completo em ambiente de produção
- [x] Investigar e corrigir erro 500 na autenticação (/api/auth/me)
  - [x] Testar login e fluxo autenticado para garantir persistência de sessão
  - [x] Conferir variáveis de ambiente do banco de dados (DATABASE_URL, SESSION_SECRET)
  - [x] Corrigir/atualizar comando de migração Drizzle ORM para PostgreSQL (`npx drizzle-kit generate:pg` e `npx drizzle-kit up:pg`)
  - [x] Gerar migrações iniciais Drizzle ORM e criar diretório migrations
  - [x] Executar migrações do banco de dados para garantir que as tabelas estejam criadas
  - [x] Testar queries diretamente no banco e garantir que usuários existem
  - [x] Adicionar logs detalhados no backend para identificar falha
  - [x] Testar novamente o endpoint autenticado e analisar os logs
  - [x] Resolver conflitos de dependências ao instalar pacotes necessários (`npm install --legacy-peer-deps` ou `--force`)
  - [x] Analisar persistência da sessão e consulta ao banco no endpoint /api/auth/me para identificar causa do erro 500
- [x] Integrar suporte à Groq API no pipeline de IA
- [x] Instalar dependência groq-sdk no projeto
- [x] Testar geração de conteúdo com Groq e fallback
- [x] Propor fluxo de telas e experiência do usuário (UX/UI)
- [ ] Sugerir wireframes/componentes React para onboarding, wizard, histórico, dashboards e exibição multimídia
- [ ] Montar roadmap de evolução do frontend e experiência
- [x] Implementar estrutura visual moderna (layout, animações, gifs, onboarding, navegação Discord-like, tema Tailwind customizado)
- [x] Corrigir avisos de compatibilidade CSS (backdrop-filter, -webkit-backdrop-filter)
- [x] Revisar/testar tema customizado no frontend
- [x] Criar componente Sidebar (AppSidebar) integrado ao layout
- [x] Criar componente MainLayout para estrutura geral
- [x] Criar hook de autenticação (use-auth) para login/logout
- [x] Criar AuthProvider para contexto global de autenticação
- [x] Criar componentes de formulário de Login e Registro (LoginForm, RegisterForm)
- [x] Criar páginas de Login e Registro integradas ao fluxo de autenticação
- [x] Atualizar MainLayout para integrar AppHeader e AppFooter
- [x] Instalar dependências essenciais do frontend (react-router-dom, lucide-react)
- [x] Criar/ajustar arquivo de ícones personalizados (ui/icons.tsx)
- [x] Corrigir imports e garantir integração dos ícones em todos os componentes
- [ ] Criar componentes principais: Wizard, Editor, MediaPlayer, ProjectCard, etc
  - [ ] Validar requisitos e layout desejado para cada componente
  - [ ] Levantar dados/mockups necessários para prototipação
- [ ] Integrar frontend com backend para fluxo completo
  - [ ] Confirmar endpoints e autenticação disponíveis
  - [ ] Testar comunicação e tratar erros
  - [ ] Validar integração final em produção
- [x] Avaliar migração do serviço de requisições de fetch para Axios OU manter padrão atual
  - [x] Decidir padrão definitivo para requisições HTTP no frontend
  - [x] Documentar prós/contras e impacto para integração futura
- [x] Criar serviço de API robusto e tipado em lib/api.ts
- [x] Atualizar serviço de autenticação (auth.ts) para usar novo serviço de API
- [ ] Integrar novos endpoints e fluxos usando o serviço de API
  - [x] Criar hook de autenticação centralizado (use-auth.tsx)
  - [x] Atualizar AuthProvider para consumir novo hook
  - [x] Refatorar componentes para usar novo hook/contexto
  - [x] Criar componente ProtectedRoute para rotas autenticadas
  - [x] Atualizar estrutura de rotas para usar ProtectedRoute
  - [x] Criar hook useUser para operações de perfil, senha e avatar
  - [x] Criar componente UserProfile para exibição e edição do perfil
  - [x] Criar componente ChangePasswordForm para alteração de senha
  - [x] Criar página de configurações com abas (settings/index.tsx)
  - [x] Criar página de configurações de perfil (settings/profile.tsx)
  - [x] Criar página de configurações de segurança (settings/security.tsx)
  - [x] Criar página de configurações de notificações (settings/notifications.tsx)
  - [x] Criar página de configurações de assinatura (settings/billing.tsx)
  - [x] Finalizar integração e navegação das configurações no frontend
- [x] Preparar ambiente e scripts para deploy final
- [x] Iniciar testes do servidor de desenvolvimento e fluxo completo
- [x] Revisar e corrigir o build do frontend (Vite) para eliminar erros de exportação e dependências e permitir testes integrados
- [x] Investigar e resolver erro de rede (ECONNRESET) no npm install
- [x] Resolver conflito de dependências entre Vite e @tailwindcss/vite para permitir o build
- [x] Testar o build e rodar o monorepo após ajuste de dependências
- [x] Testar o build e rodar o monorepo integrado (client + server)
- [x] Validar integração completa do monorepo (client + server) em ambiente de desenvolvimento.

## Current Goal
Sugerir próximos componentes React e wireframes para evolução